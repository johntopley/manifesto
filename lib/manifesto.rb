require 'digest/md5'
require 'find'

class Manifesto
  
  # Returns an Array of non-hidden files within the <tt>./public</tt> directory, unless <tt>:directory</tt> is specified.
  # The output also includes a computed hash of the files' contents, unless <tt>:compute_hash</tt> is set to <tt>false</tt>.
  #
  # === Examples
  #
  # Basic usage, list all non-hidden files in <tt>./public</tt> and include a computed hash of their contents:
  #   Manifesto.cache
  #
  # Specify a directory:
  #   Manifesto.cache :directory => './mobile'
  #
  # Specify a directory and don't compute the hash:
  #   Manifesto.cache :directory => './mobile', :compute_hash => false
  def self.cache(options = {})
    directory = options.fetch(:directory, './public')
    compute_hash  = options.fetch(:compute_hash, true)
    timestamp = options.fetch(:timestamp, true)
    timestamp_exclusions = options.fetch(:timestamp_exclusions, [])
    validate_options(directory, compute_hash, timestamp)
    manifest = []
    hashes = ''
    
    get_file_paths(directory).each do |path|
    
      # Only include real files (i.e. not directories, symlinks etc.) and non-hidden
      # files in the manifest.
      if File.file?(path) && File.basename(path)[0,1] != '.'
        if timestamp and not in_path(path, timestamp_exclusions)
          manifest << "#{normalize_path(directory, path)}?#{get_timestamp(path)}\n"
        else
          manifest << "#{normalize_path(directory, path)}\n"
        end
        hashes += compute_file_contents_hash(path) if compute_hash
      end
    end
    
    # Hash the hashes of each file and output as a comment.
    manifest << "# Hash: #{Digest::MD5.hexdigest(hashes)}\n" if compute_hash
    manifest << "# Generated by manifesto (http://github.com/johntopley/manifesto)\n"
    manifest << "CACHE MANIFEST\n"
    manifest.reverse.join
  end
  
  # Reads the file contents to calculate the MD5 hash, so that if a file is
  # changed, the manifest is changed too.
  def self.compute_file_contents_hash(path)
    hash = ''
    digest = Digest::MD5.new
    File.open(path, 'r') do |file|
      digest.update(file.read(8192)) until file.eof
      hash += digest.hexdigest
    end
    hash
  end
  
  # Recursively finds all file entries from within a directory.
  def self.get_file_paths(directory)
    entries = []
    Find.find(directory) { |entry| entries << entry }
    entries
  end
  
  # Strips the directory from the start of path, so that each path is relative
  # to directory. Add a leading forward slash if not present.
  def self.normalize_path(directory, path)
    normalized_path = path[directory.length,path.length]
    normalized_path = '/' + normalized_path unless normalized_path[0,1] == '/'
    normalized_path
  end

  # Calculates the timestamp for a given file using same methodology as Rails' asset timestamps.
  def self.get_timestamp(path)
    File.mtime(path).to_i.to_s
  end

  # Determines whether or not the path contains any of the targets; used for exclusions/inclusions.
  def self.in_path(path, targets)
    targets.each do |target|
      if path.include? target
        return true
      end
    end
    false
  end
  
  # Checks that the options passed to the <tt>cache</tt> method are valid.
  def self.validate_options(directory, compute_hash, timestamp)
    raise(ArgumentError, ":directory must be a real directory") unless valid_directory?(directory)
    raise(ArgumentError, ":compute_hash must be a boolean") unless valid_compute_hash?(compute_hash)
    raise(ArgumentError, ":timestamp must be a boolean") unless valid_timestamp?(timestamp)
  end
  
  # Checks that the <tt>compute_hash</tt> option is a boolean.
  def self.valid_compute_hash?(compute_hash)
    compute_hash.is_a?(TrueClass) || compute_hash.is_a?(FalseClass)
  end
  
  # Checks that the <tt>directory</tt> option corresponds to a real directory.
  def self.valid_directory?(directory)
    File.directory?(directory)
  end

  # Checks that the <tt>timestamp</tt> option is a boolean.
  def self.valid_timestamp?(timestamp)
    timestamp.is_a?(TrueClass) || timestamp.is_a?(FalseClass)
  end
end
